define(["exports","./when-7ef6387a","./Check-ed6a1804","./Math-85667bf9","./Cartesian3-2a8ef78e","./Transforms-2448ecca","./Cartesian2-dcadeea9","./ComponentDatatype-a863af81","./GeometryAttribute-a3332dc3","./PrimitiveType-4c1d698a","./GeometryAttributes-cb18da36","./IndexDatatype-f12d39b5","./GeometryOffsetAttribute-5cfc2755","./VertexFormat-d75df48f","./CylinderGeometryLibrary-e2d41c6a"],(function(e,t,r,a,o,n,i,s,u,d,f,m,p,l,y){"use strict";var b=new i.Cartesian2,c=new o.Cartesian3,v=new o.Cartesian3,A=new o.Cartesian3,h=new o.Cartesian3;function w(e){var a=(e=t.defaultValue(e,t.defaultValue.EMPTY_OBJECT)).length,o=e.topRadius,n=e.bottomRadius,i=t.defaultValue(e.vertexFormat,l.VertexFormat.DEFAULT),s=t.defaultValue(e.slices,128);if(!t.defined(a))throw new r.DeveloperError("options.length must be defined.");if(!t.defined(o))throw new r.DeveloperError("options.topRadius must be defined.");if(!t.defined(n))throw new r.DeveloperError("options.bottomRadius must be defined.");if(s<3)throw new r.DeveloperError("options.slices must be greater than or equal to 3.");if(t.defined(e.offsetAttribute)&&e.offsetAttribute===p.GeometryOffsetAttribute.TOP)throw new r.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=a,this._topRadius=o,this._bottomRadius=n,this._vertexFormat=l.VertexFormat.clone(i),this._slices=s,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderGeometry"}w.packedLength=l.VertexFormat.packedLength+5,w.pack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("value is required");if(!t.defined(a))throw new r.DeveloperError("array is required");return o=t.defaultValue(o,0),l.VertexFormat.pack(e._vertexFormat,a,o),o+=l.VertexFormat.packedLength,a[o++]=e._length,a[o++]=e._topRadius,a[o++]=e._bottomRadius,a[o++]=e._slices,a[o]=t.defaultValue(e._offsetAttribute,-1),a};var g,x=new l.VertexFormat,_={vertexFormat:x,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};w.unpack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("array is required");a=t.defaultValue(a,0);var n=l.VertexFormat.unpack(e,a,x);a+=l.VertexFormat.packedLength;var i=e[a++],s=e[a++],u=e[a++],d=e[a++],f=e[a];return t.defined(o)?(o._vertexFormat=l.VertexFormat.clone(n,o._vertexFormat),o._length=i,o._topRadius=s,o._bottomRadius=u,o._slices=d,o._offsetAttribute=-1===f?void 0:f,o):(_.length=i,_.topRadius=s,_.bottomRadius=u,_.slices=d,_.offsetAttribute=-1===f?void 0:f,new w(_))},w.createGeometry=function(e){var r=e._length,l=e._topRadius,w=e._bottomRadius,g=e._vertexFormat,x=e._slices;if(!(r<=0||l<0||w<0||0===l&&0===w)){var _,C=x+x,F=x+C,D=C+C,G=y.CylinderGeometryLibrary.computePositions(r,l,w,x,!0),R=g.st?new Float32Array(2*D):void 0,O=g.normal?new Float32Array(3*D):void 0,T=g.tangent?new Float32Array(3*D):void 0,V=g.bitangent?new Float32Array(3*D):void 0,E=g.normal||g.tangent||g.bitangent;if(E){var L=g.tangent||g.bitangent,P=0,k=0,M=0,z=Math.atan2(w-l,r),N=c;N.z=Math.sin(z);var I=Math.cos(z),U=A,S=v;for(_=0;_<x;_++){var q=_/x*a.CesiumMath.TWO_PI,B=I*Math.cos(q),Y=I*Math.sin(q);E&&(N.x=B,N.y=Y,L&&(U=o.Cartesian3.normalize(o.Cartesian3.cross(o.Cartesian3.UNIT_Z,N,U),U)),g.normal&&(O[P++]=N.x,O[P++]=N.y,O[P++]=N.z,O[P++]=N.x,O[P++]=N.y,O[P++]=N.z),g.tangent&&(T[k++]=U.x,T[k++]=U.y,T[k++]=U.z,T[k++]=U.x,T[k++]=U.y,T[k++]=U.z),g.bitangent&&(S=o.Cartesian3.normalize(o.Cartesian3.cross(N,U,S),S),V[M++]=S.x,V[M++]=S.y,V[M++]=S.z,V[M++]=S.x,V[M++]=S.y,V[M++]=S.z))}for(_=0;_<x;_++)g.normal&&(O[P++]=0,O[P++]=0,O[P++]=-1),g.tangent&&(T[k++]=1,T[k++]=0,T[k++]=0),g.bitangent&&(V[M++]=0,V[M++]=-1,V[M++]=0);for(_=0;_<x;_++)g.normal&&(O[P++]=0,O[P++]=0,O[P++]=1),g.tangent&&(T[k++]=1,T[k++]=0,T[k++]=0),g.bitangent&&(V[M++]=0,V[M++]=1,V[M++]=0)}var Z=12*x-12,J=m.IndexDatatype.createTypedArray(D,Z),W=0,j=0;for(_=0;_<x-1;_++)J[W++]=j,J[W++]=j+2,J[W++]=j+3,J[W++]=j,J[W++]=j+3,J[W++]=j+1,j+=2;for(J[W++]=C-2,J[W++]=0,J[W++]=1,J[W++]=C-2,J[W++]=1,J[W++]=C-1,_=1;_<x-1;_++)J[W++]=C+_+1,J[W++]=C+_,J[W++]=C;for(_=1;_<x-1;_++)J[W++]=F,J[W++]=F+_,J[W++]=F+_+1;var H=0;if(g.st){var K=Math.max(l,w);for(_=0;_<D;_++){var Q=o.Cartesian3.fromArray(G,3*_,h);R[H++]=(Q.x+K)/(2*K),R[H++]=(Q.y+K)/(2*K)}}var X=new f.GeometryAttributes;g.position&&(X.position=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G})),g.normal&&(X.normal=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),g.tangent&&(X.tangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),g.bitangent&&(X.bitangent=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),g.st&&(X.st=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R})),b.x=.5*r,b.y=Math.max(w,l);var $=new n.BoundingSphere(o.Cartesian3.ZERO,i.Cartesian2.magnitude(b));if(t.defined(e._offsetAttribute)){r=G.length;var ee=new Uint8Array(r/3),te=e._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1;p.arrayFill(ee,te),X.applyOffset=new u.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:ee})}return new u.Geometry({attributes:X,indices:J,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:$,offsetAttribute:e._offsetAttribute})}},w.getUnitCylinder=function(){return t.defined(g)||(g=w.createGeometry(new w({topRadius:1,bottomRadius:1,length:1,vertexFormat:l.VertexFormat.POSITION_ONLY}))),g},e.CylinderGeometry=w}));
//# sourceMappingURL=CylinderGeometry-8103b44c.js.map
