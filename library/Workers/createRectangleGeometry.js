/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2017 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["./when-4ca4e419","./Check-430b3551","./defineProperties-163ddb68","./Cartesian3-32451e63","./Ellipsoid-d2aa3b12","./Transforms-7b04d7e0","./Matrix4-33464f2b","./RuntimeError-443472b0","./Cartesian2-f49a1383","./FeatureDetection-0d4fee13","./WebGLConstants-2ddfa2f9","./ComponentDatatype-329b9462","./GeometryAttribute-b8faa946","./GeometryAttributes-614c63f8","./AttributeCompression-7809eba4","./GeometryPipeline-f9bdb2cf","./EncodedCartesian3-63b18b5e","./IndexDatatype-153fdd7f","./IntersectionTests-15d018f5","./Plane-84b14a0a","./arrayFill-11a46844","./VertexFormat-a4fe3a21","./GeometryInstance-d03f2889","./EllipsoidRhumbLine-c004db91","./PolygonPipeline-d25dad97","./RectangleGeometryLibrary-b86d2dd6"],(function(t,e,a,r,n,o,i,s,l,u,c,d,p,m,g,y,f,h,v,b,_,A,w,x,C,R){"use strict";var E=new r.Cartesian3,F=new r.Cartesian3,G=new r.Cartesian3,P=new r.Cartesian3,D=new l.Rectangle,V=new l.Cartesian2,L=new o.BoundingSphere,M=new o.BoundingSphere;function O(t,e){var a=new p.Geometry({attributes:new m.GeometryAttributes,primitiveType:p.PrimitiveType.TRIANGLES});return a.attributes.position=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(a.attributes.normal=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(a.attributes.tangent=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(a.attributes.bitangent=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),a}var T=new r.Cartesian3,N=new r.Cartesian3;function k(t,e){var a=t._vertexFormat,n=t._ellipsoid,o=e.height,s=e.width,l=e.northCap,u=e.southCap,c=0,m=o,g=o,y=0;l&&(c=1,g-=1,y+=1),u&&(m-=1,g-=1,y+=1),y+=s*g;for(var f=a.position?new Float64Array(3*y):void 0,v=a.st?new Float32Array(2*y):void 0,b=0,_=0,A=E,w=V,x=Number.MAX_VALUE,C=Number.MAX_VALUE,D=-Number.MAX_VALUE,L=-Number.MAX_VALUE,M=c;M<m;++M)for(var T=0;T<s;++T)R.RectangleGeometryLibrary.computePosition(e,n,a.st,M,T,A,w),f[b++]=A.x,f[b++]=A.y,f[b++]=A.z,a.st&&(v[_++]=w.x,v[_++]=w.y,x=Math.min(x,w.x),C=Math.min(C,w.y),D=Math.max(D,w.x),L=Math.max(L,w.y));if(l&&(R.RectangleGeometryLibrary.computePosition(e,n,a.st,0,0,A,w),f[b++]=A.x,f[b++]=A.y,f[b++]=A.z,a.st&&(v[_++]=w.x,v[_++]=w.y,x=w.x,C=w.y,D=w.x,L=w.y)),u&&(R.RectangleGeometryLibrary.computePosition(e,n,a.st,o-1,0,A,w),f[b++]=A.x,f[b++]=A.y,f[b]=A.z,a.st&&(v[_++]=w.x,v[_]=w.y,x=Math.min(x,w.x),C=Math.min(C,w.y),D=Math.max(D,w.x),L=Math.max(L,w.y))),a.st&&(x<0||C<0||D>1||L>1))for(var N=0;N<v.length;N+=2)v[N]=(v[N]-x)/(D-x),v[N+1]=(v[N+1]-C)/(L-C);var k=function(t,e,a,n){var o=t.length,s=e.normal?new Float32Array(o):void 0,l=e.tangent?new Float32Array(o):void 0,u=e.bitangent?new Float32Array(o):void 0,c=0,d=P,p=G,m=F;if(e.normal||e.tangent||e.bitangent)for(var g=0;g<o;g+=3){var y=r.Cartesian3.fromArray(t,g,E),f=c+1,h=c+2;m=a.geodeticSurfaceNormal(y,m),(e.tangent||e.bitangent)&&(r.Cartesian3.cross(r.Cartesian3.UNIT_Z,m,p),i.Matrix3.multiplyByVector(n,p,p),r.Cartesian3.normalize(p,p),e.bitangent&&r.Cartesian3.normalize(r.Cartesian3.cross(m,p,d),d)),e.normal&&(s[c]=m.x,s[f]=m.y,s[h]=m.z),e.tangent&&(l[c]=p.x,l[f]=p.y,l[h]=p.z),e.bitangent&&(u[c]=d.x,u[f]=d.y,u[h]=d.z),c+=3}return O(e,{positions:t,normals:s,tangents:l,bitangents:u})}(f,a,n,e.tangentRotationMatrix),S=6*(s-1)*(g-1);l&&(S+=3*(s-1)),u&&(S+=3*(s-1));var I,H=h.IndexDatatype.createTypedArray(y,S),z=0,B=0;for(I=0;I<g-1;++I){for(var U=0;U<s-1;++U){var q=z,Y=q+s,X=Y+1,j=q+1;H[B++]=q,H[B++]=Y,H[B++]=j,H[B++]=j,H[B++]=Y,H[B++]=X,++z}++z}if(l||u){var Q,W,J=y-1,Z=y-1;if(l&&u&&(J=y-2),z=0,l)for(I=0;I<s-1;I++)W=(Q=z)+1,H[B++]=J,H[B++]=Q,H[B++]=W,++z;if(u)for(z=(g-1)*s,I=0;I<s-1;I++)W=(Q=z)+1,H[B++]=Q,H[B++]=Z,H[B++]=W,++z}return k.indices=H,a.st&&(k.attributes.st=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:v})),k}function S(t,e,a,r,n){return t[e++]=r[a],t[e++]=r[a+1],t[e++]=r[a+2],t[e++]=n[a],t[e++]=n[a+1],t[e]=n[a+2],t}function I(t,e,a,r){return t[e++]=r[a],t[e++]=r[a+1],t[e++]=r[a],t[e]=r[a+1],t}var H=new A.VertexFormat;function z(e,n){var o,i=e._shadowVolume,s=e._offsetAttribute,l=e._vertexFormat,u=e._extrudedHeight,c=e._surfaceHeight,m=e._ellipsoid,g=n.height,f=n.width;if(i){var v=A.VertexFormat.clone(l,H);v.normal=!0,e._vertexFormat=v}var b=k(e,n);i&&(e._vertexFormat=l);var x=C.PolygonPipeline.scaleToGeodeticHeight(b.attributes.position.values,c,m,!1),R=(x=new Float64Array(x)).length,D=2*R,V=new Float64Array(D);V.set(x);var L=C.PolygonPipeline.scaleToGeodeticHeight(b.attributes.position.values,u,m);V.set(L,R),b.attributes.position.values=V;var M,z,B,U=l.normal?new Float32Array(D):void 0,q=l.tangent?new Float32Array(D):void 0,Y=l.bitangent?new Float32Array(D):void 0,X=l.st?new Float32Array(D/3*2):void 0;if(l.normal){for(z=b.attributes.normal.values,U.set(z),o=0;o<R;o++)z[o]=-z[o];U.set(z,R),b.attributes.normal.values=U}if(i){z=b.attributes.normal.values,l.normal||(b.attributes.normal=void 0);var j=new Float32Array(D);for(o=0;o<R;o++)z[o]=-z[o];j.set(z,R),b.attributes.extrudeDirection=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})}var Q=t.defined(s);if(Q){var W=R/3*2,J=new Uint8Array(W);s===p.GeometryOffsetAttribute.TOP?J=_.arrayFill(J,1,0,W/2):(B=s===p.GeometryOffsetAttribute.NONE?0:1,J=_.arrayFill(J,B)),b.attributes.applyOffset=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:J})}if(l.tangent){var Z=b.attributes.tangent.values;for(q.set(Z),o=0;o<R;o++)Z[o]=-Z[o];q.set(Z,R),b.attributes.tangent.values=q}if(l.bitangent){var K=b.attributes.bitangent.values;Y.set(K),Y.set(K,R),b.attributes.bitangent.values=Y}l.st&&(M=b.attributes.st.values,X.set(M),X.set(M,R/3*2),b.attributes.st.values=X);var $=b.indices,tt=$.length,et=R/3,at=h.IndexDatatype.createTypedArray(D/3,2*tt);for(at.set($),o=0;o<tt;o+=3)at[o+tt]=$[o+2]+et,at[o+1+tt]=$[o+1]+et,at[o+2+tt]=$[o]+et;b.indices=at;var rt=n.northCap,nt=n.southCap,ot=g,it=2,st=0,lt=4,ut=4;rt&&(it-=1,ot-=1,st+=1,lt-=2,ut-=1),nt&&(it-=1,ot-=1,st+=1,lt-=2,ut-=1);var ct=2*((st+=it*f+2*ot-lt)+ut),dt=new Float64Array(3*ct),pt=i?new Float32Array(3*ct):void 0,mt=Q?new Uint8Array(ct):void 0,gt=l.st?new Float32Array(2*ct):void 0,yt=s===p.GeometryOffsetAttribute.TOP;Q&&!yt&&(B=s===p.GeometryOffsetAttribute.ALL?1:0,mt=_.arrayFill(mt,B));var ft,ht=0,vt=0,bt=0,_t=0,At=f*ot;for(o=0;o<At;o+=f)dt=S(dt,ht,ft=3*o,x,L),ht+=6,l.st&&(gt=I(gt,vt,2*o,M),vt+=4),i&&(bt+=3,pt[bt++]=z[ft],pt[bt++]=z[ft+1],pt[bt++]=z[ft+2]),yt&&(mt[_t++]=1,_t+=1);if(nt){var wt=rt?At+1:At;for(ft=3*wt,o=0;o<2;o++)dt=S(dt,ht,ft,x,L),ht+=6,l.st&&(gt=I(gt,vt,2*wt,M),vt+=4),i&&(bt+=3,pt[bt++]=z[ft],pt[bt++]=z[ft+1],pt[bt++]=z[ft+2]),yt&&(mt[_t++]=1,_t+=1)}else for(o=At-f;o<At;o++)dt=S(dt,ht,ft=3*o,x,L),ht+=6,l.st&&(gt=I(gt,vt,2*o,M),vt+=4),i&&(bt+=3,pt[bt++]=z[ft],pt[bt++]=z[ft+1],pt[bt++]=z[ft+2]),yt&&(mt[_t++]=1,_t+=1);for(o=At-1;o>0;o-=f)dt=S(dt,ht,ft=3*o,x,L),ht+=6,l.st&&(gt=I(gt,vt,2*o,M),vt+=4),i&&(bt+=3,pt[bt++]=z[ft],pt[bt++]=z[ft+1],pt[bt++]=z[ft+2]),yt&&(mt[_t++]=1,_t+=1);if(rt){var xt=At;for(ft=3*xt,o=0;o<2;o++)dt=S(dt,ht,ft,x,L),ht+=6,l.st&&(gt=I(gt,vt,2*xt,M),vt+=4),i&&(bt+=3,pt[bt++]=z[ft],pt[bt++]=z[ft+1],pt[bt++]=z[ft+2]),yt&&(mt[_t++]=1,_t+=1)}else for(o=f-1;o>=0;o--)dt=S(dt,ht,ft=3*o,x,L),ht+=6,l.st&&(gt=I(gt,vt,2*o,M),vt+=4),i&&(bt+=3,pt[bt++]=z[ft],pt[bt++]=z[ft+1],pt[bt++]=z[ft+2]),yt&&(mt[_t++]=1,_t+=1);var Ct=function(t,e,n){var o=t.length,i=e.normal?new Float32Array(o):void 0,s=e.tangent?new Float32Array(o):void 0,l=e.bitangent?new Float32Array(o):void 0,u=0,c=0,d=0,p=!0,m=P,g=G,y=F;if(e.normal||e.tangent||e.bitangent)for(var f=0;f<o;f+=6){var h=r.Cartesian3.fromArray(t,f,E),v=r.Cartesian3.fromArray(t,(f+6)%o,T);if(p){var b=r.Cartesian3.fromArray(t,(f+3)%o,N);r.Cartesian3.subtract(v,h,v),r.Cartesian3.subtract(b,h,b),y=r.Cartesian3.normalize(r.Cartesian3.cross(b,v,y),y),p=!1}r.Cartesian3.equalsEpsilon(v,h,a.CesiumMath.EPSILON10)&&(p=!0),(e.tangent||e.bitangent)&&(m=n.geodeticSurfaceNormal(h,m),e.tangent&&(g=r.Cartesian3.normalize(r.Cartesian3.cross(m,y,g),g))),e.normal&&(i[u++]=y.x,i[u++]=y.y,i[u++]=y.z,i[u++]=y.x,i[u++]=y.y,i[u++]=y.z),e.tangent&&(s[c++]=g.x,s[c++]=g.y,s[c++]=g.z,s[c++]=g.x,s[c++]=g.y,s[c++]=g.z),e.bitangent&&(l[d++]=m.x,l[d++]=m.y,l[d++]=m.z,l[d++]=m.x,l[d++]=m.y,l[d++]=m.z)}return O(e,{positions:t,normals:i,tangents:s,bitangents:l})}(dt,l,m);l.st&&(Ct.attributes.st=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:gt})),i&&(Ct.attributes.extrudeDirection=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:pt})),Q&&(Ct.attributes.applyOffset=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:mt}));var Rt,Et,Ft,Gt,Pt=h.IndexDatatype.createTypedArray(ct,6*st);R=dt.length/3;var Dt=0;for(o=0;o<R-1;o+=2){Gt=((Rt=o)+2)%R;var Vt=r.Cartesian3.fromArray(dt,3*Rt,T),Lt=r.Cartesian3.fromArray(dt,3*Gt,N);r.Cartesian3.equalsEpsilon(Vt,Lt,a.CesiumMath.EPSILON10)||(Ft=((Et=(Rt+1)%R)+2)%R,Pt[Dt++]=Rt,Pt[Dt++]=Et,Pt[Dt++]=Gt,Pt[Dt++]=Gt,Pt[Dt++]=Et,Pt[Dt++]=Ft)}return Ct.indices=Pt,(Ct=y.GeometryPipeline.combineInstances([new w.GeometryInstance({geometry:b}),new w.GeometryInstance({geometry:Ct})]))[0]}var B=[new r.Cartesian3,new r.Cartesian3,new r.Cartesian3,new r.Cartesian3],U=new n.Cartographic,q=new n.Cartographic;function Y(t,e,a,r,n){if(0===a)return l.Rectangle.clone(t,n);var o=R.RectangleGeometryLibrary.computeOptions(t,e,a,0,D,U),i=o.height,s=o.width,u=B;return R.RectangleGeometryLibrary.computePosition(o,r,!1,0,0,u[0]),R.RectangleGeometryLibrary.computePosition(o,r,!1,0,s-1,u[1]),R.RectangleGeometryLibrary.computePosition(o,r,!1,i-1,0,u[2]),R.RectangleGeometryLibrary.computePosition(o,r,!1,i-1,s-1,u[3]),l.Rectangle.fromCartesianArray(u,r,n)}function X(r){var o=(r=t.defaultValue(r,t.defaultValue.EMPTY_OBJECT)).rectangle;if(e.Check.typeOf.object("rectangle",o),l.Rectangle.validate(o),o.north<o.south)throw new e.DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");var i=t.defaultValue(r.height,0),s=t.defaultValue(r.extrudedHeight,i);this._rectangle=l.Rectangle.clone(o),this._granularity=t.defaultValue(r.granularity,a.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=n.Ellipsoid.clone(t.defaultValue(r.ellipsoid,n.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(i,s),this._rotation=t.defaultValue(r.rotation,0),this._stRotation=t.defaultValue(r.stRotation,0),this._vertexFormat=A.VertexFormat.clone(t.defaultValue(r.vertexFormat,A.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(i,s),this._shadowVolume=t.defaultValue(r.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=r.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}X.packedLength=l.Rectangle.packedLength+n.Ellipsoid.packedLength+A.VertexFormat.packedLength+7,X.pack=function(a,r,o){return e.Check.typeOf.object("value",a),e.Check.defined("array",r),o=t.defaultValue(o,0),l.Rectangle.pack(a._rectangle,r,o),o+=l.Rectangle.packedLength,n.Ellipsoid.pack(a._ellipsoid,r,o),o+=n.Ellipsoid.packedLength,A.VertexFormat.pack(a._vertexFormat,r,o),o+=A.VertexFormat.packedLength,r[o++]=a._granularity,r[o++]=a._surfaceHeight,r[o++]=a._rotation,r[o++]=a._stRotation,r[o++]=a._extrudedHeight,r[o++]=a._shadowVolume?1:0,r[o]=t.defaultValue(a._offsetAttribute,-1),r};var j=new l.Rectangle,Q=n.Ellipsoid.clone(n.Ellipsoid.UNIT_SPHERE),W={rectangle:j,ellipsoid:Q,vertexFormat:H,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};X.unpack=function(a,r,o){e.Check.defined("array",a),r=t.defaultValue(r,0);var i=l.Rectangle.unpack(a,r,j);r+=l.Rectangle.packedLength;var s=n.Ellipsoid.unpack(a,r,Q);r+=n.Ellipsoid.packedLength;var u=A.VertexFormat.unpack(a,r,H);r+=A.VertexFormat.packedLength;var c=a[r++],d=a[r++],p=a[r++],m=a[r++],g=a[r++],y=1===a[r++],f=a[r];return t.defined(o)?(o._rectangle=l.Rectangle.clone(i,o._rectangle),o._ellipsoid=n.Ellipsoid.clone(s,o._ellipsoid),o._vertexFormat=A.VertexFormat.clone(u,o._vertexFormat),o._granularity=c,o._surfaceHeight=d,o._rotation=p,o._stRotation=m,o._extrudedHeight=g,o._shadowVolume=y,o._offsetAttribute=-1===f?void 0:f,o):(W.granularity=c,W.height=d,W.rotation=p,W.stRotation=m,W.extrudedHeight=g,W.shadowVolume=y,W.offsetAttribute=-1===f?void 0:f,new X(W))},X.computeRectangle=function(r,o){var i=(r=t.defaultValue(r,t.defaultValue.EMPTY_OBJECT)).rectangle;if(e.Check.typeOf.object("rectangle",i),l.Rectangle.validate(i),i.north<i.south)throw new e.DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");var s=t.defaultValue(r.granularity,a.CesiumMath.RADIANS_PER_DEGREE),u=t.defaultValue(r.ellipsoid,n.Ellipsoid.WGS84);return Y(i,s,t.defaultValue(r.rotation,0),u,o)};var J=new i.Matrix3,Z=new o.Quaternion,K=new n.Cartographic;X.createGeometry=function(e){if(!a.CesiumMath.equalsEpsilon(e._rectangle.north,e._rectangle.south,a.CesiumMath.EPSILON10)&&!a.CesiumMath.equalsEpsilon(e._rectangle.east,e._rectangle.west,a.CesiumMath.EPSILON10)){var r=e._rectangle,n=e._ellipsoid,s=e._rotation,u=e._stRotation,c=e._vertexFormat,m=R.RectangleGeometryLibrary.computeOptions(r,e._granularity,s,u,D,U,q),g=J;if(0!==u||0!==s){var y=l.Rectangle.center(r,K),f=n.geodeticSurfaceNormalCartographic(y,T);o.Quaternion.fromAxisAngle(f,-u,Z),i.Matrix3.fromQuaternion(Z,g)}else i.Matrix3.clone(i.Matrix3.IDENTITY,g);var h,v,b=e._surfaceHeight,A=e._extrudedHeight,w=!a.CesiumMath.equalsEpsilon(b,A,0,a.CesiumMath.EPSILON2);if(m.lonScalar=1/e._rectangle.width,m.latScalar=1/e._rectangle.height,m.tangentRotationMatrix=g,r=e._rectangle,w){h=z(e,m);var x=o.BoundingSphere.fromRectangle3D(r,n,b,M),E=o.BoundingSphere.fromRectangle3D(r,n,A,L);v=o.BoundingSphere.union(x,E)}else{if((h=k(e,m)).attributes.position.values=C.PolygonPipeline.scaleToGeodeticHeight(h.attributes.position.values,b,n,!1),t.defined(e._offsetAttribute)){var F=h.attributes.position.values.length,G=new Uint8Array(F/3),P=e._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1;_.arrayFill(G,P),h.attributes.applyOffset=new p.GeometryAttribute({componentDatatype:d.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:G})}v=o.BoundingSphere.fromRectangle3D(r,n,b)}return c.position||delete h.attributes.position,new p.Geometry({attributes:h.attributes,indices:h.indices,primitiveType:h.primitiveType,boundingSphere:v,offsetAttribute:e._offsetAttribute})}},X.createShadowVolume=function(t,e,a){var r=t._granularity,n=t._ellipsoid,o=e(r,n),i=a(r,n);return new X({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:n,stRotation:t._stRotation,granularity:r,extrudedHeight:i,height:o,vertexFormat:A.VertexFormat.POSITION_ONLY,shadowVolume:!0})};var $=new l.Rectangle,tt=[new l.Cartesian2,new l.Cartesian2,new l.Cartesian2],et=new p.Matrix2,at=new n.Cartographic;return a.defineProperties(X.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=Y(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];var e=l.Rectangle.clone(t._rectangle,$),a=t._granularity,r=t._ellipsoid,n=Y(e,a,t._rotation-t._stRotation,r,$),o=tt;o[0].x=n.west,o[0].y=n.south,o[1].x=n.west,o[1].y=n.north,o[2].x=n.east,o[2].y=n.south;for(var i=t.rectangle,s=p.Matrix2.fromRotation(t._stRotation,et),u=l.Rectangle.center(i,at),c=0;c<3;++c){var d=o[c];d.x-=u.longitude,d.y-=u.latitude,p.Matrix2.multiplyByVector(s,d,d),d.x+=u.longitude,d.y+=u.latitude,d.x=(d.x-i.west)/i.width,d.y=(d.y-i.south)/i.height}var m=o[0],g=o[1],y=o[2],f=new Array(6);return l.Cartesian2.pack(m,f),l.Cartesian2.pack(g,f,2),l.Cartesian2.pack(y,f,4),f}(this)),this._textureCoordinateRotationPoints}}}),function(e,a){return t.defined(a)&&(e=X.unpack(e,a)),e._ellipsoid=n.Ellipsoid.clone(e._ellipsoid),e._rectangle=l.Rectangle.clone(e._rectangle),X.createGeometry(e)}}));
