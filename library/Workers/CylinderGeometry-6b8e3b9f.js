define(["exports","./when-7ef6387a","./DeveloperError-101d8eb9","./Cartesian3-ca5d3f12","./Transforms-7a1c9ee7","./Cartesian2-d6edb867","./ComponentDatatype-f4fabeaa","./GeometryAttribute-c5b9902a","./PrimitiveType-4c1d698a","./GeometryAttributes-cb18da36","./IndexDatatype-bfeda8ca","./GeometryOffsetAttribute-19130c81","./VertexFormat-64d8e6c6","./CylinderGeometryLibrary-c69898f4"],(function(e,t,r,a,o,n,i,s,u,m,d,f,p,l){"use strict";var y=new n.Cartesian2,b=new a.Cartesian3,c=new a.Cartesian3,v=new a.Cartesian3,A=new a.Cartesian3;function h(e){var a=(e=t.defaultValue(e,t.defaultValue.EMPTY_OBJECT)).length,o=e.topRadius,n=e.bottomRadius,i=t.defaultValue(e.vertexFormat,p.VertexFormat.DEFAULT),s=t.defaultValue(e.slices,128);if(!t.defined(a))throw new r.DeveloperError("options.length must be defined.");if(!t.defined(o))throw new r.DeveloperError("options.topRadius must be defined.");if(!t.defined(n))throw new r.DeveloperError("options.bottomRadius must be defined.");if(s<3)throw new r.DeveloperError("options.slices must be greater than or equal to 3.");if(t.defined(e.offsetAttribute)&&e.offsetAttribute===f.GeometryOffsetAttribute.TOP)throw new r.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=a,this._topRadius=o,this._bottomRadius=n,this._vertexFormat=p.VertexFormat.clone(i),this._slices=s,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderGeometry"}h.packedLength=p.VertexFormat.packedLength+5,h.pack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("value is required");if(!t.defined(a))throw new r.DeveloperError("array is required");return o=t.defaultValue(o,0),p.VertexFormat.pack(e._vertexFormat,a,o),o+=p.VertexFormat.packedLength,a[o++]=e._length,a[o++]=e._topRadius,a[o++]=e._bottomRadius,a[o++]=e._slices,a[o]=t.defaultValue(e._offsetAttribute,-1),a};var w,g=new p.VertexFormat,x={vertexFormat:g,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};h.unpack=function(e,a,o){if(!t.defined(e))throw new r.DeveloperError("array is required");a=t.defaultValue(a,0);var n=p.VertexFormat.unpack(e,a,g);a+=p.VertexFormat.packedLength;var i=e[a++],s=e[a++],u=e[a++],m=e[a++],d=e[a];return t.defined(o)?(o._vertexFormat=p.VertexFormat.clone(n,o._vertexFormat),o._length=i,o._topRadius=s,o._bottomRadius=u,o._slices=m,o._offsetAttribute=-1===d?void 0:d,o):(x.length=i,x.topRadius=s,x.bottomRadius=u,x.slices=m,x.offsetAttribute=-1===d?void 0:d,new h(x))},h.createGeometry=function(e){var r=e._length,p=e._topRadius,h=e._bottomRadius,w=e._vertexFormat,g=e._slices;if(!(r<=0||p<0||h<0||0===p&&0===h)){var x,_=g+g,C=g+_,F=_+_,D=l.CylinderGeometryLibrary.computePositions(r,p,h,g,!0),G=w.st?new Float32Array(2*F):void 0,R=w.normal?new Float32Array(3*F):void 0,O=w.tangent?new Float32Array(3*F):void 0,T=w.bitangent?new Float32Array(3*F):void 0,E=w.normal||w.tangent||w.bitangent;if(E){var V=w.tangent||w.bitangent,L=0,P=0,k=0,z=Math.atan2(h-p,r),M=b;M.z=Math.sin(z);var N=Math.cos(z),I=v,U=c;for(x=0;x<g;x++){var S=x/g*a.CesiumMath.TWO_PI,q=N*Math.cos(S),B=N*Math.sin(S);E&&(M.x=q,M.y=B,V&&(I=a.Cartesian3.normalize(a.Cartesian3.cross(a.Cartesian3.UNIT_Z,M,I),I)),w.normal&&(R[L++]=M.x,R[L++]=M.y,R[L++]=M.z,R[L++]=M.x,R[L++]=M.y,R[L++]=M.z),w.tangent&&(O[P++]=I.x,O[P++]=I.y,O[P++]=I.z,O[P++]=I.x,O[P++]=I.y,O[P++]=I.z),w.bitangent&&(U=a.Cartesian3.normalize(a.Cartesian3.cross(M,I,U),U),T[k++]=U.x,T[k++]=U.y,T[k++]=U.z,T[k++]=U.x,T[k++]=U.y,T[k++]=U.z))}for(x=0;x<g;x++)w.normal&&(R[L++]=0,R[L++]=0,R[L++]=-1),w.tangent&&(O[P++]=1,O[P++]=0,O[P++]=0),w.bitangent&&(T[k++]=0,T[k++]=-1,T[k++]=0);for(x=0;x<g;x++)w.normal&&(R[L++]=0,R[L++]=0,R[L++]=1),w.tangent&&(O[P++]=1,O[P++]=0,O[P++]=0),w.bitangent&&(T[k++]=0,T[k++]=1,T[k++]=0)}var Y=12*g-12,Z=d.IndexDatatype.createTypedArray(F,Y),J=0,W=0;for(x=0;x<g-1;x++)Z[J++]=W,Z[J++]=W+2,Z[J++]=W+3,Z[J++]=W,Z[J++]=W+3,Z[J++]=W+1,W+=2;for(Z[J++]=_-2,Z[J++]=0,Z[J++]=1,Z[J++]=_-2,Z[J++]=1,Z[J++]=_-1,x=1;x<g-1;x++)Z[J++]=_+x+1,Z[J++]=_+x,Z[J++]=_;for(x=1;x<g-1;x++)Z[J++]=C,Z[J++]=C+x,Z[J++]=C+x+1;var j=0;if(w.st){var H=Math.max(p,h);for(x=0;x<F;x++){var K=a.Cartesian3.fromArray(D,3*x,A);G[j++]=(K.x+H)/(2*H),G[j++]=(K.y+H)/(2*H)}}var Q=new m.GeometryAttributes;w.position&&(Q.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D})),w.normal&&(Q.normal=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),w.tangent&&(Q.tangent=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),w.bitangent&&(Q.bitangent=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),w.st&&(Q.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:G})),y.x=.5*r,y.y=Math.max(h,p);var X=new o.BoundingSphere(a.Cartesian3.ZERO,n.Cartesian2.magnitude(y));if(t.defined(e._offsetAttribute)){r=D.length;var $=new Uint8Array(r/3),ee=e._offsetAttribute===f.GeometryOffsetAttribute.NONE?0:1;f.arrayFill($,ee),Q.applyOffset=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:$})}return new s.Geometry({attributes:Q,indices:Z,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:X,offsetAttribute:e._offsetAttribute})}},h.getUnitCylinder=function(){return t.defined(w)||(w=h.createGeometry(new h({topRadius:1,bottomRadius:1,length:1,vertexFormat:p.VertexFormat.POSITION_ONLY}))),w},e.CylinderGeometry=h}));
//# sourceMappingURL=CylinderGeometry-6b8e3b9f.js.map
