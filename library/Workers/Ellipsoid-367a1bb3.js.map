{"version":3,"file":"Ellipsoid-367a1bb3.js","sources":["../../../../Source/Core/scaleToGeodeticSurface.js","../../../../Source/Core/Cartographic.js","../../../../Source/Core/Ellipsoid.js"],"sourcesContent":["import Cartesian3 from './Cartesian3.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\n\r\n    var scaleToGeodeticSurfaceIntersection = new Cartesian3();\r\n    var scaleToGeodeticSurfaceGradient = new Cartesian3();\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geodetic surface normal\r\n     * so that it is on the surface of this ellipsoid.  If the position is\r\n     * at the center of the ellipsoid, this function returns undefined.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\r\n     * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\r\n     * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n     *\r\n     * @exports scaleToGeodeticSurface\r\n     *\r\n     * @private\r\n     */\r\n    function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(cartesian)) {\r\n            throw new DeveloperError('cartesian is required.');\r\n        }\r\n        if (!defined(oneOverRadii)) {\r\n            throw new DeveloperError('oneOverRadii is required.');\r\n        }\r\n        if (!defined(oneOverRadiiSquared)) {\r\n            throw new DeveloperError('oneOverRadiiSquared is required.');\r\n        }\r\n        if (!defined(centerToleranceSquared)) {\r\n            throw new DeveloperError('centerToleranceSquared is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var positionX = cartesian.x;\r\n        var positionY = cartesian.y;\r\n        var positionZ = cartesian.z;\r\n\r\n        var oneOverRadiiX = oneOverRadii.x;\r\n        var oneOverRadiiY = oneOverRadii.y;\r\n        var oneOverRadiiZ = oneOverRadii.z;\r\n\r\n        var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\r\n        var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\r\n        var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\r\n\r\n        // Compute the squared ellipsoid norm.\r\n        var squaredNorm = x2 + y2 + z2;\r\n        var ratio = Math.sqrt(1.0 / squaredNorm);\r\n\r\n        // As an initial approximation, assume that the radial intersection is the projection point.\r\n        var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);\r\n\r\n        // If the position is near the center, the iteration will not converge.\r\n        if (squaredNorm < centerToleranceSquared) {\r\n            return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);\r\n        }\r\n\r\n        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\r\n        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\r\n        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\r\n\r\n        // Use the gradient at the intersection point in place of the true unit normal.\r\n        // The difference in magnitude will be absorbed in the multiplier.\r\n        var gradient = scaleToGeodeticSurfaceGradient;\r\n        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\r\n        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\r\n        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\r\n\r\n        // Compute the initial guess at the normal vector multiplier, lambda.\r\n        var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));\r\n        var correction = 0.0;\r\n\r\n        var func;\r\n        var denominator;\r\n        var xMultiplier;\r\n        var yMultiplier;\r\n        var zMultiplier;\r\n        var xMultiplier2;\r\n        var yMultiplier2;\r\n        var zMultiplier2;\r\n        var xMultiplier3;\r\n        var yMultiplier3;\r\n        var zMultiplier3;\r\n\r\n        do {\r\n            lambda -= correction;\r\n\r\n            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\r\n            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\r\n            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\r\n\r\n            xMultiplier2 = xMultiplier * xMultiplier;\r\n            yMultiplier2 = yMultiplier * yMultiplier;\r\n            zMultiplier2 = zMultiplier * zMultiplier;\r\n\r\n            xMultiplier3 = xMultiplier2 * xMultiplier;\r\n            yMultiplier3 = yMultiplier2 * yMultiplier;\r\n            zMultiplier3 = zMultiplier2 * zMultiplier;\r\n\r\n            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\r\n\r\n            // \"denominator\" here refers to the use of this expression in the velocity and acceleration\r\n            // computations in the sections to follow.\r\n            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\r\n\r\n            var derivative = -2.0 * denominator;\r\n\r\n            correction = func / derivative;\r\n        } while (Math.abs(func) > CesiumMath.EPSILON12);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\r\n        }\r\n        result.x = positionX * xMultiplier;\r\n        result.y = positionY * yMultiplier;\r\n        result.z = positionZ * zMultiplier;\r\n        return result;\r\n    }\r\nexport default scaleToGeodeticSurface;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport CesiumMath from './Math.js';\r\nimport scaleToGeodeticSurface from './scaleToGeodeticSurface.js';\r\n\r\n    /**\r\n     * A position defined by longitude, latitude, and height.\r\n     * @alias Cartographic\r\n     * @constructor\r\n     *\r\n     * @param {Number} [longitude=0.0] The longitude, in radians.\r\n     * @param {Number} [latitude=0.0] The latitude, in radians.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     *\r\n     * @see Ellipsoid\r\n     */\r\n    function Cartographic(longitude, latitude, height) {\r\n        /**\r\n         * The longitude, in radians.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.longitude = defaultValue(longitude, 0.0);\r\n\r\n        /**\r\n         * The latitude, in radians.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.latitude = defaultValue(latitude, 0.0);\r\n\r\n        /**\r\n         * The height, in meters, above the ellipsoid.\r\n         * @type {Number}\r\n         * @default 0.0\r\n         */\r\n        this.height = defaultValue(height, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from longitude and latitude\r\n     * specified in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in radians.\r\n     * @param {Number} latitude The latitude, in radians.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.fromRadians = function(longitude, latitude, height, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('longitude', longitude);\r\n        Check.typeOf.number('latitude', latitude);\r\n        //>>includeEnd('debug');\r\n\r\n        height = defaultValue(height, 0.0);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from longitude and latitude\r\n     * specified in degrees.  The values in the resulting object will\r\n     * be in radians.\r\n     *\r\n     * @param {Number} longitude The longitude, in degrees.\r\n     * @param {Number} latitude The latitude, in degrees.\r\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.fromDegrees = function(longitude, latitude, height, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('longitude', longitude);\r\n        Check.typeOf.number('latitude', latitude);\r\n        //>>includeEnd('debug');\r\n        longitude = CesiumMath.toRadians(longitude);\r\n        latitude = CesiumMath.toRadians(latitude);\r\n\r\n        return Cartographic.fromRadians(longitude, latitude, height, result);\r\n    };\r\n\r\n    var cartesianToCartographicN = new Cartesian3();\r\n    var cartesianToCartographicP = new Cartesian3();\r\n    var cartesianToCartographicH = new Cartesian3();\r\n    var wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);\r\n    var wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));\r\n    var wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n    /**\r\n     * Creates a new Cartographic instance from a Cartesian position. The values in the\r\n     * resulting object will be in radians.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n     */\r\n    Cartographic.fromCartesian = function(cartesian, ellipsoid, result) {\r\n        var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;\r\n        var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;\r\n        var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;\r\n\r\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n        var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);\r\n\r\n        if (!defined(p)) {\r\n            return undefined;\r\n        }\r\n\r\n        var n = Cartesian3.multiplyComponents(p, oneOverRadiiSquared, cartesianToCartographicN);\r\n        n = Cartesian3.normalize(n, n);\r\n\r\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n        var longitude = Math.atan2(n.y, n.x);\r\n        var latitude = Math.asin(n.z);\r\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\r\n     * object should be in radians.\r\n     *\r\n     * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The position\r\n     */\r\n    Cartographic.toCartesian = function(cartographic, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        return Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic.height, ellipsoid, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a Cartographic instance.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic to duplicate.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\r\n     */\r\n    Cartographic.clone = function(cartographic, result) {\r\n        if (!defined(cartographic)) {\r\n            return undefined;\r\n        }\r\n        if (!defined(result)) {\r\n            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);\r\n        }\r\n        result.longitude = cartographic.longitude;\r\n        result.latitude = cartographic.latitude;\r\n        result.height = cartographic.height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Compares the provided cartographics componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [left] The first cartographic.\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.equals = function(left, right) {\r\n        return (left === right) ||\r\n                ((defined(left)) &&\r\n                 (defined(right)) &&\r\n                 (left.longitude === right.longitude) &&\r\n                 (left.latitude === right.latitude) &&\r\n                 (left.height === right.height));\r\n    };\r\n\r\n    /**\r\n     * Compares the provided cartographics componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [left] The first cartographic.\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.equalsEpsilon = function(left, right, epsilon) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number('epsilon', epsilon);\r\n        //>>includeEnd('debug');\r\n\r\n        return (left === right) ||\r\n               ((defined(left)) &&\r\n                (defined(right)) &&\r\n                (Math.abs(left.longitude - right.longitude) <= epsilon) &&\r\n                (Math.abs(left.latitude - right.latitude) <= epsilon) &&\r\n                (Math.abs(left.height - right.height) <= epsilon));\r\n    };\r\n\r\n    /**\r\n     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\r\n     *\r\n     * @type {Cartographic}\r\n     * @constant\r\n     */\r\n    Cartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\r\n\r\n    /**\r\n     * Duplicates this instance.\r\n     *\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\r\n     */\r\n    Cartographic.prototype.clone = function(result) {\r\n        return Cartographic.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided against this cartographic componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.prototype.equals = function(right) {\r\n        return Cartographic.equals(this, right);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided against this cartographic componentwise and returns\r\n     * <code>true</code> if they are within the provided epsilon,\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @param {Cartographic} [right] The second cartographic.\r\n     * @param {Number} epsilon The epsilon to use for equality testing.\r\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\r\n     */\r\n    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {\r\n        return Cartographic.equalsEpsilon(this, right, epsilon);\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\r\n     *\r\n     * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\r\n     */\r\n    Cartographic.prototype.toString = function() {\r\n        return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';\r\n    };\r\nexport default Cartographic;\r\n","import Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport CesiumMath from './Math.js';\r\nimport scaleToGeodeticSurface from './scaleToGeodeticSurface.js';\r\n\r\n    function initialize(ellipsoid, x, y, z) {\r\n        x = defaultValue(x, 0.0);\r\n        y = defaultValue(y, 0.0);\r\n        z = defaultValue(z, 0.0);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.number.greaterThanOrEquals('x', x, 0.0);\r\n        Check.typeOf.number.greaterThanOrEquals('y', y, 0.0);\r\n        Check.typeOf.number.greaterThanOrEquals('z', z, 0.0);\r\n        //>>includeEnd('debug');\r\n\r\n        ellipsoid._radii = new Cartesian3(x, y, z);\r\n\r\n        ellipsoid._radiiSquared = new Cartesian3(x * x,\r\n                                            y * y,\r\n                                            z * z);\r\n\r\n        ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x,\r\n                                                y * y * y * y,\r\n                                                z * z * z * z);\r\n\r\n        ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x,\r\n                                            y === 0.0 ? 0.0 : 1.0 / y,\r\n                                            z === 0.0 ? 0.0 : 1.0 / z);\r\n\r\n        ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x),\r\n                                                   y === 0.0 ? 0.0 : 1.0 / (y * y),\r\n                                                   z === 0.0 ? 0.0 : 1.0 / (z * z));\r\n\r\n        ellipsoid._minimumRadius = Math.min(x, y, z);\r\n\r\n        ellipsoid._maximumRadius = Math.max(x, y, z);\r\n\r\n        ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\r\n\r\n        if (ellipsoid._radiiSquared.z !== 0) {\r\n            ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A quadratic surface defined in Cartesian coordinates by the equation\r\n     * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\r\n     * by Cesium to represent the shape of planetary bodies.\r\n     *\r\n     * Rather than constructing this object directly, one of the provided\r\n     * constants is normally used.\r\n     * @alias Ellipsoid\r\n     * @constructor\r\n     *\r\n     * @param {Number} [x=0] The radius in the x direction.\r\n     * @param {Number} [y=0] The radius in the y direction.\r\n     * @param {Number} [z=0] The radius in the z direction.\r\n     *\r\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n     *\r\n     * @see Ellipsoid.fromCartesian3\r\n     * @see Ellipsoid.WGS84\r\n     * @see Ellipsoid.UNIT_SPHERE\r\n     */\r\n    function Ellipsoid(x, y, z) {\r\n        this._radii = undefined;\r\n        this._radiiSquared = undefined;\r\n        this._radiiToTheFourth = undefined;\r\n        this._oneOverRadii = undefined;\r\n        this._oneOverRadiiSquared = undefined;\r\n        this._minimumRadius = undefined;\r\n        this._maximumRadius = undefined;\r\n        this._centerToleranceSquared = undefined;\r\n        this._squaredXOverSquaredZ = undefined;\r\n\r\n        initialize(this, x, y, z);\r\n    }\r\n\r\n    Object.defineProperties(Ellipsoid.prototype, {\r\n        /**\r\n         * Gets the radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radii : {\r\n            get: function() {\r\n                return this._radii;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the squared radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radiiSquared : {\r\n            get : function() {\r\n                return this._radiiSquared;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the radii of the ellipsoid raise to the fourth power.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        radiiToTheFourth : {\r\n            get : function() {\r\n                return this._radiiToTheFourth;\r\n            }\r\n        },\r\n        /**\r\n         * Gets one over the radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        oneOverRadii : {\r\n            get : function() {\r\n                return this._oneOverRadii;\r\n            }\r\n        },\r\n        /**\r\n         * Gets one over the squared radii of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Cartesian3}\r\n         * @readonly\r\n         */\r\n        oneOverRadiiSquared : {\r\n            get : function() {\r\n                return this._oneOverRadiiSquared;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the minimum radius of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        minimumRadius : {\r\n            get : function() {\r\n                return this._minimumRadius;\r\n            }\r\n        },\r\n        /**\r\n         * Gets the maximum radius of the ellipsoid.\r\n         * @memberof Ellipsoid.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         */\r\n        maximumRadius : {\r\n            get : function() {\r\n                return this._maximumRadius;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Duplicates an Ellipsoid instance.\r\n     *\r\n     * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\r\n     */\r\n    Ellipsoid.clone = function(ellipsoid, result) {\r\n        if (!defined(ellipsoid)) {\r\n            return undefined;\r\n        }\r\n        var radii = ellipsoid._radii;\r\n\r\n        if (!defined(result)) {\r\n            return new Ellipsoid(radii.x, radii.y, radii.z);\r\n        }\r\n\r\n        Cartesian3.clone(radii, result._radii);\r\n        Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\r\n        Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\r\n        Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\r\n        Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\r\n        result._minimumRadius = ellipsoid._minimumRadius;\r\n        result._maximumRadius = ellipsoid._maximumRadius;\r\n        result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\r\n     *\r\n     * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} A new Ellipsoid instance.\r\n     *\r\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\r\n     *\r\n     * @see Ellipsoid.WGS84\r\n     * @see Ellipsoid.UNIT_SPHERE\r\n     */\r\n    Ellipsoid.fromCartesian3 = function(cartesian, result) {\r\n        if (!defined(result)) {\r\n            result = new Ellipsoid();\r\n        }\r\n\r\n        if (!defined(cartesian)) {\r\n            return result;\r\n        }\r\n\r\n        initialize(result, cartesian.x, cartesian.y, cartesian.z);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to the WGS84 standard.\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.WGS84 = Object.freeze(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\r\n\r\n    /**\r\n     * An Ellipsoid instance initialized to a sphere with the lunar radius.\r\n     *\r\n     * @type {Ellipsoid}\r\n     * @constant\r\n     */\r\n    Ellipsoid.MOON = Object.freeze(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\r\n\r\n    /**\r\n     * Duplicates an Ellipsoid instance.\r\n     *\r\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\r\n     *                    instance should be created.\r\n     * @returns {Ellipsoid} The cloned Ellipsoid.\r\n     */\r\n    Ellipsoid.prototype.clone = function(result) {\r\n        return Ellipsoid.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    Ellipsoid.packedLength = Cartesian3.packedLength;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {Ellipsoid} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    Ellipsoid.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value._radii, array, startingIndex);\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {Ellipsoid} [result] The object into which to store the result.\r\n     * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\r\n     */\r\n    Ellipsoid.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var radii = Cartesian3.unpack(array, startingIndex);\r\n        return Ellipsoid.fromCartesian3(radii, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\r\n     * @function\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\r\n\r\n    /**\r\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartographic', cartographic);\r\n        //>>includeEnd('debug');\r\n\r\n        var longitude = cartographic.longitude;\r\n        var latitude = cartographic.latitude;\r\n        var cosLatitude = Math.cos(latitude);\r\n\r\n        var x = cosLatitude * Math.cos(longitude);\r\n        var y = cosLatitude * Math.sin(longitude);\r\n        var z = Math.sin(latitude);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    /**\r\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\r\n        return Cartesian3.normalize(result, result);\r\n    };\r\n\r\n    var cartographicToCartesianNormal = new Cartesian3();\r\n    var cartographicToCartesianK = new Cartesian3();\r\n\r\n    /**\r\n     * Converts the provided cartographic to Cartesian representation.\r\n     *\r\n     * @param {Cartographic} cartographic The cartographic position.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\r\n     * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\r\n     * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\r\n     */\r\n    Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {\r\n        //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\r\n        var n = cartographicToCartesianNormal;\r\n        var k = cartographicToCartesianK;\r\n        this.geodeticSurfaceNormalCartographic(cartographic, n);\r\n        Cartesian3.multiplyComponents(this._radiiSquared, n, k);\r\n        var gamma = Math.sqrt(Cartesian3.dot(n, k));\r\n        Cartesian3.divideByScalar(k, gamma, k);\r\n        Cartesian3.multiplyByScalar(n, cartographic.height, n);\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n        return Cartesian3.add(k, n, result);\r\n    };\r\n\r\n    /**\r\n     * Converts the provided array of cartographics to an array of Cartesians.\r\n     *\r\n     * @param {Cartographic[]} cartographics An array of cartographic positions.\r\n     * @param {Cartesian3[]} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\r\n     * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\r\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\r\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\r\n     * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\r\n     */\r\n    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartographics', cartographics);\r\n        //>>includeEnd('debug')\r\n\r\n        var length = cartographics.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n        for ( var i = 0; i < length; i++) {\r\n            result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    var cartesianToCartographicN = new Cartesian3();\r\n    var cartesianToCartographicP = new Cartesian3();\r\n    var cartesianToCartographicH = new Cartesian3();\r\n\r\n    /**\r\n     * Converts the provided cartesian to cartographic representation.\r\n     * The cartesian is undefined at the center of the ellipsoid.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\r\n     * @param {Cartographic} [result] The object onto which to store the result.\r\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\r\n     *\r\n     * @example\r\n     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\r\n     * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\r\n     * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\r\n     */\r\n    Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {\r\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\r\n        var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\r\n\r\n        if (!defined(p)) {\r\n            return undefined;\r\n        }\r\n\r\n        var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\r\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\r\n\r\n        var longitude = Math.atan2(n.y, n.x);\r\n        var latitude = Math.asin(n.z);\r\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\r\n\r\n        if (!defined(result)) {\r\n            return new Cartographic(longitude, latitude, height);\r\n        }\r\n        result.longitude = longitude;\r\n        result.latitude = latitude;\r\n        result.height = height;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Converts the provided array of cartesians to an array of cartographics.\r\n     *\r\n     * @param {Cartesian3[]} cartesians An array of Cartesian positions.\r\n     * @param {Cartographic[]} [result] The object onto which to store the result.\r\n     * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\r\n     *\r\n     * @example\r\n     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\r\n     * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\r\n     *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\r\n     *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\r\n     * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\r\n     */\r\n    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('cartesians', cartesians);\r\n        //>>includeEnd('debug');\r\n\r\n        var length = cartesians.length;\r\n        if (!defined(result)) {\r\n            result = new Array(length);\r\n        } else {\r\n            result.length = length;\r\n        }\r\n        for ( var i = 0; i < length; ++i) {\r\n            result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geodetic surface normal\r\n     * so that it is on the surface of this ellipsoid.  If the position is\r\n     * at the center of the ellipsoid, this function returns undefined.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\r\n     */\r\n    Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {\r\n        return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);\r\n    };\r\n\r\n    /**\r\n     * Scales the provided Cartesian position along the geocentric surface normal\r\n     * so that it is on the surface of this ellipsoid.\r\n     *\r\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\r\n     * @param {Cartesian3} [result] The object onto which to store the result.\r\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\r\n     */\r\n    Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('cartesian', cartesian);\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        var positionX = cartesian.x;\r\n        var positionY = cartesian.y;\r\n        var positionZ = cartesian.z;\r\n        var oneOverRadiiSquared = this._oneOverRadiiSquared;\r\n\r\n        var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x +\r\n                                   (positionY * positionY) * oneOverRadiiSquared.y +\r\n                                   (positionZ * positionZ) * oneOverRadiiSquared.z);\r\n\r\n        return Cartesian3.multiplyByScalar(cartesian, beta, result);\r\n    };\r\n\r\n    /**\r\n     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\r\n     * its components by the result of {@link Ellipsoid#oneOverRadii}.\r\n     *\r\n     * @param {Cartesian3} position The position to transform.\r\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\r\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n     */\r\n    Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\r\n    };\r\n\r\n    /**\r\n     * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\r\n     * its components by the result of {@link Ellipsoid#radii}.\r\n     *\r\n     * @param {Cartesian3} position The position to transform.\r\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\r\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\r\n     */\r\n    Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        return Cartesian3.multiplyComponents(position, this._radii, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {Ellipsoid} [right] The other Ellipsoid.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    Ellipsoid.prototype.equals = function(right) {\r\n        return (this === right) ||\r\n               (defined(right) &&\r\n                Cartesian3.equals(this._radii, right._radii));\r\n    };\r\n\r\n    /**\r\n     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n     *\r\n     * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\r\n     */\r\n    Ellipsoid.prototype.toString = function() {\r\n        return this._radii.toString();\r\n    };\r\n\r\n    /**\r\n     * Computes a point which is the intersection of the surface normal with the z-axis.\r\n     *\r\n     * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\r\n     * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\r\n     *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\r\n     *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\r\n     *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\r\n     * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\r\n     *        return a new instance.\r\n     * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\r\n     *\r\n     * @exception {DeveloperError} position is required.\r\n     * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\r\n     * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\r\n     */\r\n    Ellipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function(position, buffer, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('position', position);\r\n\r\n        if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {\r\n            throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');\r\n        }\r\n\r\n        Check.typeOf.number.greaterThan('Ellipsoid.radii.z', this._radii.z, 0);\r\n        //>>includeEnd('debug');\r\n\r\n        buffer = defaultValue(buffer, 0.0);\r\n\r\n        var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\r\n\r\n        if (!defined(result)) {\r\n            result = new Cartesian3();\r\n        }\r\n\r\n        result.x = 0.0;\r\n        result.y = 0.0;\r\n        result.z = position.z * (1 - squaredXOverSquaredZ);\r\n\r\n        if (Math.abs(result.z) >= this._radii.z - buffer) {\r\n            return undefined;\r\n        }\r\n\r\n        return result;\r\n    };\r\nexport default Ellipsoid;\r\n"],"names":["scaleToGeodeticSurfaceIntersection","Cartesian3","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","cartesian","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","result","defined","DeveloperError","positionX","x","positionY","y","positionZ","z","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","sqrt","intersection","multiplyByScalar","isFinite","clone","undefined","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","func","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","lambda","magnitude","correction","abs","CesiumMath","EPSILON12","Cartographic","longitude","latitude","height","this","defaultValue","fromRadians","Check","typeOf","number","fromDegrees","toRadians","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","wgs84OneOverRadii","wgs84OneOverRadiiSquared","wgs84CenterToleranceSquared","EPSILON1","initialize","ellipsoid","greaterThanOrEquals","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","min","_maximumRadius","max","_centerToleranceSquared","_squaredXOverSquaredZ","Ellipsoid","fromCartesian","p","n","multiplyComponents","normalize","h","subtract","atan2","asin","sign","dot","toCartesian","cartographic","equals","left","right","equalsEpsilon","epsilon","ZERO","Object","freeze","prototype","toString","defineProperties","radii","get","radiiSquared","radiiToTheFourth","minimumRadius","maximumRadius","fromCartesian3","WGS84","UNIT_SPHERE","MOON","LUNAR_RADIUS","packedLength","pack","value","array","startingIndex","object","unpack","geocentricSurfaceNormal","geodeticSurfaceNormalCartographic","cosLatitude","cos","sin","geodeticSurfaceNormal","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","k","gamma","divideByScalar","add","cartographicArrayToCartesianArray","cartographics","length","Array","i","cartesianToCartographic","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ"],"mappings":"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"}