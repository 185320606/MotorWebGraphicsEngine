/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2017 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["./when-4ca4e419","./Check-430b3551","./defineProperties-163ddb68","./Cartesian3-32451e63","./Ellipsoid-d2aa3b12","./Transforms-7b04d7e0","./Matrix4-33464f2b","./RuntimeError-443472b0","./Cartesian2-f49a1383","./FeatureDetection-0d4fee13","./WebGLConstants-2ddfa2f9","./ComponentDatatype-329b9462","./AttributeCompression-7809eba4","./IndexDatatype-153fdd7f","./IntersectionTests-15d018f5","./Plane-84b14a0a","./WebMercatorProjection-72bc39e7","./createTaskProcessorWorker","./EllipsoidTangentPlane-3967708f","./OrientedBoundingBox-51e874ad","./TerrainEncoding-5ed40ec6"],(function(e,t,r,i,n,a,o,s,d,u,m,c,h,l,I,g,T,M,b,f,p){"use strict";var C=new i.Cartesian3,N=new i.Cartesian3,x=new i.Cartesian3,y=new n.Cartographic,v=new d.Cartesian2,w=new i.Cartesian3,A=new o.Matrix4,E=new o.Matrix4;function P(e,t,n,a,s,d,u,m,c){var h=Number.POSITIVE_INFINITY,l=s.north,I=s.south,g=s.east,T=s.west;g<T&&(g+=r.CesiumMath.TWO_PI);for(var M=e.length,b=0;b<M;++b){var f=e[b],p=n[f],N=a[f];y.longitude=r.CesiumMath.lerp(T,g,N.x),y.latitude=r.CesiumMath.lerp(I,l,N.y),y.height=p-t;var x=d.cartographicToCartesian(y,C);o.Matrix4.multiplyByPoint(u,x,x),i.Cartesian3.minimumByComponent(x,m,m),i.Cartesian3.maximumByComponent(x,c,c),h=Math.min(h,y.height)}return h}function B(t,n,s,d,u,m,c,l,I,g,M,b,f,p,N,x,P,B){var F,S,V;f?(F=u.length-1,S=-1,V=-1):(F=0,S=u.length,V=1);var _=-1,k=e.defined(I),H=n/m.getStride(),W=M.north,Y=M.south,O=M.east,z=M.west;O<z&&(O+=r.CesiumMath.TWO_PI);for(var D=F;D!==S;D+=V){var G=u[D],j=c[G],L=l[G];y.longitude=r.CesiumMath.lerp(z,O,L.x)+P,y.latitude=r.CesiumMath.lerp(Y,W,L.y)+B,y.height=j-b;var U,R=g.cartographicToCartesian(y,C);if(k){var q=2*G;if(v.x=I[q],v.y=I[q+1],1!==p){var J=h.AttributeCompression.octDecode(v.x,v.y,w),K=a.Transforms.eastNorthUpToFixedFrame(C,g,E),Q=o.Matrix4.inverseTransformation(K,A);o.Matrix4.multiplyByPointAsVector(Q,J,J),J.z*=p,i.Cartesian3.normalize(J,J),o.Matrix4.multiplyByPointAsVector(K,J,J),i.Cartesian3.normalize(J,J),h.AttributeCompression.octEncode(J,v)}}m.hasWebMercatorT&&(U=(T.WebMercatorProjection.geodeticLatitudeToMercatorAngle(y.latitude)-N)*x),n=m.encode(t,n,R,L,y.height,v,U),-1!==_&&(s[d++]=_,s[d++]=H-1,s[d++]=G,s[d++]=H-1,s[d++]=H,s[d++]=G),_=G,++H}return d}return M((function(t,s){var u,m,c=t.quantizedVertices,I=c.length/3,g=t.octEncodedNormals,M=t.westIndices.length+t.eastIndices.length+t.southIndices.length+t.northIndices.length,F=t.includeWebMercatorT,S=t.rectangle,V=S.west,_=S.south,k=S.east,H=S.north,W=n.Ellipsoid.clone(t.ellipsoid),Y=t.exaggeration,O=t.minimumHeight*Y,z=t.maximumHeight*Y,D=t.relativeToCenter,G=a.Transforms.eastNorthUpToFixedFrame(D,W),j=o.Matrix4.inverseTransformation(G,new o.Matrix4);F&&(u=T.WebMercatorProjection.geodeticLatitudeToMercatorAngle(_),m=1/(T.WebMercatorProjection.geodeticLatitudeToMercatorAngle(H)-u));var L=c.subarray(0,I),U=c.subarray(I,2*I),R=c.subarray(2*I,3*I),q=e.defined(g),J=new Array(I),K=new Array(I),Q=new Array(I),X=F?new Array(I):[],Z=N;Z.x=Number.POSITIVE_INFINITY,Z.y=Number.POSITIVE_INFINITY,Z.z=Number.POSITIVE_INFINITY;var $=x;$.x=Number.NEGATIVE_INFINITY,$.y=Number.NEGATIVE_INFINITY,$.z=Number.NEGATIVE_INFINITY;for(var ee,te,re=Number.POSITIVE_INFINITY,ie=Number.NEGATIVE_INFINITY,ne=Number.POSITIVE_INFINITY,ae=Number.NEGATIVE_INFINITY,oe=0;oe<I;++oe){var se=L[oe]/32767,de=U[oe]/32767,ue=r.CesiumMath.lerp(O,z,R[oe]/32767);y.longitude=r.CesiumMath.lerp(V,k,se),y.latitude=r.CesiumMath.lerp(_,H,de),y.height=ue,re=Math.min(y.longitude,re),ie=Math.max(y.longitude,ie),ne=Math.min(y.latitude,ne),ae=Math.max(y.latitude,ae);var me=W.cartographicToCartesian(y);J[oe]=new d.Cartesian2(se,de),K[oe]=ue,Q[oe]=me,F&&(X[oe]=(T.WebMercatorProjection.geodeticLatitudeToMercatorAngle(y.latitude)-u)*m),o.Matrix4.multiplyByPoint(j,me,C),i.Cartesian3.minimumByComponent(C,Z,Z),i.Cartesian3.maximumByComponent(C,$,$)}1!==Y&&(te=a.BoundingSphere.fromPoints(Q),ee=f.OrientedBoundingBox.fromRectangle(S,O,z,W));var ce=O;ce=Math.min(ce,P(t.westIndices,t.westSkirtHeight,K,J,S,W,j,Z,$)),ce=Math.min(ce,P(t.southIndices,t.southSkirtHeight,K,J,S,W,j,Z,$)),ce=Math.min(ce,P(t.eastIndices,t.eastSkirtHeight,K,J,S,W,j,Z,$)),ce=Math.min(ce,P(t.northIndices,t.northSkirtHeight,K,J,S,W,j,Z,$));for(var he=new b.AxisAlignedBoundingBox(Z,$,D),le=new p.TerrainEncoding(he,ce,z,G,q,F),Ie=le.getStride(),ge=new Float32Array(I*Ie+M*Ie),Te=0,Me=0;Me<I;++Me){if(q){var be=2*Me;if(v.x=g[be],v.y=g[be+1],1!==Y){var fe=h.AttributeCompression.octDecode(v.x,v.y,w),pe=a.Transforms.eastNorthUpToFixedFrame(Q[Me],W,E),Ce=o.Matrix4.inverseTransformation(pe,A);o.Matrix4.multiplyByPointAsVector(Ce,fe,fe),fe.z*=Y,i.Cartesian3.normalize(fe,fe),o.Matrix4.multiplyByPointAsVector(pe,fe,fe),i.Cartesian3.normalize(fe,fe),h.AttributeCompression.octEncode(fe,v)}}Te=le.encode(ge,Te,Q[Me],J[Me],K[Me],v,X[Me])}var Ne=Math.max(0,2*(M-4)),xe=t.indices.length+3*Ne,ye=l.IndexDatatype.createTypedArray(I+M,xe);ye.set(t.indices,0);var ve=1e-4*(ie-re),we=1e-4*(ae-ne),Ae=-ve,Ee=ve,Pe=we,Be=-we,Fe=I*Ie,Se=t.indices.length;return Se=B(ge,Fe,ye,Se,t.westIndices,le,K,J,g,W,S,t.westSkirtHeight,!0,Y,u,m,Ae,0),Se=B(ge,Fe+=t.westIndices.length*Ie,ye,Se,t.southIndices,le,K,J,g,W,S,t.southSkirtHeight,!1,Y,u,m,0,Be),Se=B(ge,Fe+=t.southIndices.length*Ie,ye,Se,t.eastIndices,le,K,J,g,W,S,t.eastSkirtHeight,!1,Y,u,m,Ee,0),B(ge,Fe+=t.eastIndices.length*Ie,ye,Se,t.northIndices,le,K,J,g,W,S,t.northSkirtHeight,!0,Y,u,m,0,Pe),s.push(ge.buffer,ye.buffer),{vertices:ge.buffer,indices:ye.buffer,vertexStride:Ie,center:D,minimumHeight:O,maximumHeight:z,boundingSphere:te,orientedBoundingBox:ee,encoding:le,skirtIndex:t.indices.length}}))}));
