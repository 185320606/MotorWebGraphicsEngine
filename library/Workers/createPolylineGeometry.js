/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2017 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
define(["./when-4ca4e419","./Check-430b3551","./defineProperties-163ddb68","./Cartesian3-32451e63","./Ellipsoid-d2aa3b12","./Transforms-7b04d7e0","./Matrix4-33464f2b","./RuntimeError-443472b0","./Cartesian2-f49a1383","./FeatureDetection-0d4fee13","./WebGLConstants-2ddfa2f9","./ComponentDatatype-329b9462","./GeometryAttribute-b8faa946","./GeometryAttributes-614c63f8","./IndexDatatype-153fdd7f","./IntersectionTests-15d018f5","./Plane-84b14a0a","./VertexFormat-a4fe3a21","./arrayRemoveDuplicates-c3fd0b84","./ArcType-51c149e1","./EllipsoidRhumbLine-c004db91","./EllipsoidGeodesic-c57b5e5c","./PolylinePipeline-4ac94627","./Color-1501ed7a"],(function(e,r,t,o,a,i,n,l,s,p,d,c,u,f,y,m,h,v,C,w,g,E,_,b){"use strict";var A=[];function P(e,r,t,o,a){var i,n=A;n.length=a;var l=t.red,s=t.green,p=t.blue,d=t.alpha,c=o.red,u=o.green,f=o.blue,y=o.alpha;if(b.Color.equals(t,o)){for(i=0;i<a;i++)n[i]=b.Color.clone(t);return n}var m=(c-l)/a,h=(u-s)/a,v=(f-p)/a,C=(y-d)/a;for(i=0;i<a;i++)n[i]=new b.Color(l+i*m,s+i*h,p+i*v,d+i*C);return n}function T(n){var l=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).positions,s=n.colors,p=e.defaultValue(n.width,1),d=e.defaultValue(n.colorsPerVertex,!1);if(!e.defined(l)||l.length<2)throw new r.DeveloperError("At least two positions are required.");if("number"!=typeof p)throw new r.DeveloperError("width must be a number");if(e.defined(s)&&(d&&s.length<l.length||!d&&s.length<l.length-1))throw new r.DeveloperError("colors has an invalid length.");this._positions=l,this._colors=s,this._width=p,this._colorsPerVertex=d,this._vertexFormat=v.VertexFormat.clone(e.defaultValue(n.vertexFormat,v.VertexFormat.DEFAULT)),this._followSurface=e.defaultValue(n.followSurface,!0),e.defined(n.followSurface)&&(i.deprecationWarning("PolylineGeometry.followSurface","PolylineGeometry.followSurface is deprecated and will be removed in Cesium 1.55. Use PolylineGeometry.arcType instead."),n.arcType=n.followSurface?w.ArcType.GEODESIC:w.ArcType.NONE),this._arcType=e.defaultValue(n.arcType,w.ArcType.GEODESIC),this._followSurface=this._arcType!==w.ArcType.NONE,this._granularity=e.defaultValue(n.granularity,t.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=a.Ellipsoid.clone(e.defaultValue(n.ellipsoid,a.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";var c=1+l.length*o.Cartesian3.packedLength;c+=e.defined(s)?1+s.length*b.Color.packedLength:1,this.packedLength=c+a.Ellipsoid.packedLength+v.VertexFormat.packedLength+4}T.pack=function(t,i,n){if(!e.defined(t))throw new r.DeveloperError("value is required");if(!e.defined(i))throw new r.DeveloperError("array is required");var l;n=e.defaultValue(n,0);var s=t._positions,p=s.length;for(i[n++]=p,l=0;l<p;++l,n+=o.Cartesian3.packedLength)o.Cartesian3.pack(s[l],i,n);var d=t._colors;for(p=e.defined(d)?d.length:0,i[n++]=p,l=0;l<p;++l,n+=b.Color.packedLength)b.Color.pack(d[l],i,n);return a.Ellipsoid.pack(t._ellipsoid,i,n),n+=a.Ellipsoid.packedLength,v.VertexFormat.pack(t._vertexFormat,i,n),n+=v.VertexFormat.packedLength,i[n++]=t._width,i[n++]=t._colorsPerVertex?1:0,i[n++]=t._arcType,i[n]=t._granularity,i};var D=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),x=new v.VertexFormat,k={positions:void 0,colors:void 0,ellipsoid:D,vertexFormat:x,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};T.unpack=function(t,i,n){if(!e.defined(t))throw new r.DeveloperError("array is required");var l;i=e.defaultValue(i,0);var s=t[i++],p=new Array(s);for(l=0;l<s;++l,i+=o.Cartesian3.packedLength)p[l]=o.Cartesian3.unpack(t,i);var d=(s=t[i++])>0?new Array(s):void 0;for(l=0;l<s;++l,i+=b.Color.packedLength)d[l]=b.Color.unpack(t,i);var c=a.Ellipsoid.unpack(t,i,D);i+=a.Ellipsoid.packedLength;var u=v.VertexFormat.unpack(t,i,x);i+=v.VertexFormat.packedLength;var f=t[i++],y=1===t[i++],m=t[i++],h=t[i];return e.defined(n)?(n._positions=p,n._colors=d,n._ellipsoid=a.Ellipsoid.clone(c,n._ellipsoid),n._vertexFormat=v.VertexFormat.clone(u,n._vertexFormat),n._width=f,n._colorsPerVertex=y,n._arcType=m,n._granularity=h,n):(k.positions=p,k.colors=d,k.width=f,k.colorsPerVertex=y,k.arcType=m,k.granularity=h,new T(k))};var G=new o.Cartesian3,V=new o.Cartesian3,F=new o.Cartesian3,L=new o.Cartesian3;return T.createGeometry=function(r){var a,n,l,s=r._width,p=r._vertexFormat,d=r._colors,m=r._colorsPerVertex,h=r._arcType,v=r._granularity,g=r._ellipsoid,E=C.arrayRemoveDuplicates(r._positions,o.Cartesian3.equalsEpsilon),T=E.length;if(!(T<2||s<=0)){if(h===w.ArcType.GEODESIC||h===w.ArcType.RHUMB){var D,x;h===w.ArcType.GEODESIC?(D=t.CesiumMath.chordLength(v,g.maximumRadius),x=_.PolylinePipeline.numberOfPoints):(D=v,x=_.PolylinePipeline.numberOfPointsRhumbLine);var k=_.PolylinePipeline.extractHeights(E,g);if(e.defined(d)){var S=1;for(a=0;a<T-1;++a)S+=x(E[a],E[a+1],D);var O=new Array(S),I=0;for(a=0;a<T-1;++a){var R=E[a],B=E[a+1],N=d[a],U=x(R,B,D);if(m&&a<S){var q=P(0,0,N,d[a+1],U),M=q.length;for(n=0;n<M;++n)O[I++]=q[n]}else for(n=0;n<U;++n)O[I++]=b.Color.clone(N)}O[I]=b.Color.clone(d[d.length-1]),d=O,A.length=0}E=h===w.ArcType.GEODESIC?_.PolylinePipeline.generateCartesianArc({positions:E,minDistance:D,ellipsoid:g,height:k}):_.PolylinePipeline.generateCartesianRhumbArc({positions:E,granularity:D,ellipsoid:g,height:k})}var W,H=4*(T=E.length)-4,Y=new Float64Array(3*H),z=new Float64Array(3*H),J=new Float64Array(3*H),j=new Float32Array(2*H),K=p.st?new Float32Array(2*H):void 0,Q=e.defined(d)?new Uint8Array(4*H):void 0,X=0,Z=0,$=0,ee=0;for(n=0;n<T;++n){var re,te;0===n?(W=G,o.Cartesian3.subtract(E[0],E[1],W),o.Cartesian3.add(E[0],W,W)):W=E[n-1],o.Cartesian3.clone(W,F),o.Cartesian3.clone(E[n],V),n===T-1?(W=G,o.Cartesian3.subtract(E[T-1],E[T-2],W),o.Cartesian3.add(E[T-1],W,W)):W=E[n+1],o.Cartesian3.clone(W,L),e.defined(Q)&&(re=0===n||m?d[n]:d[n-1],n!==T-1&&(te=d[n]));var oe=n===T-1?2:4;for(l=0===n?2:0;l<oe;++l){o.Cartesian3.pack(V,Y,X),o.Cartesian3.pack(F,z,X),o.Cartesian3.pack(L,J,X),X+=3;var ae=l-2<0?-1:1;if(j[Z++]=l%2*2-1,j[Z++]=ae*s,p.st&&(K[$++]=n/(T-1),K[$++]=Math.max(j[Z-2],0)),e.defined(Q)){var ie=l<2?re:te;Q[ee++]=b.Color.floatToByte(ie.red),Q[ee++]=b.Color.floatToByte(ie.green),Q[ee++]=b.Color.floatToByte(ie.blue),Q[ee++]=b.Color.floatToByte(ie.alpha)}}}var ne=new f.GeometryAttributes;ne.position=new u.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:Y}),ne.prevPosition=new u.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:z}),ne.nextPosition=new u.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:J}),ne.expandAndWidth=new u.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:j}),p.st&&(ne.st=new u.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})),e.defined(Q)&&(ne.color=new u.GeometryAttribute({componentDatatype:c.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:Q,normalize:!0}));var le=y.IndexDatatype.createTypedArray(H,6*T-6),se=0,pe=0,de=T-1;for(n=0;n<de;++n)le[pe++]=se,le[pe++]=se+2,le[pe++]=se+1,le[pe++]=se+1,le[pe++]=se+2,le[pe++]=se+3,se+=4;return new u.Geometry({attributes:ne,indices:le,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:i.BoundingSphere.fromPoints(E),geometryType:u.GeometryType.POLYLINES})}},function(r,t){return e.defined(t)&&(r=T.unpack(r,t)),r._ellipsoid=a.Ellipsoid.clone(r._ellipsoid),T.createGeometry(r)}}));
